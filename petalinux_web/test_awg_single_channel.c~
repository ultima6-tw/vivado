// test_awg.c â€” update A.tone0 only, commit on the last write
#include <stdio.h>
#include <stdint.h>
#include <time.h>
#include "awg_core.h"

// Replace with your calibrated indices (0..899)
#define IDX_1K   0x001
#define IDX_20K  0x020

// Q1.17 max (20-bit)
#define GAIN_Q1_17_MAX  0x1FFFFu

// ---------- Command packing (must match RTL) ----------
static inline uint32_t pack_sel(int ch, int tone) {
    return ((uint32_t)(ch & 1) << 27) | ((uint32_t)(tone & 7) << 24);
}
// 0x1 = INDEX, 0x2 = GAIN, 0x3 = INDEX&COMMIT, 0x4 = GAIN&COMMIT
static inline uint32_t make_index_word(int ch, int tone, uint32_t idx20) {
    return (0x1u << 28) | pack_sel(ch, tone) | (idx20 & 0xFFFFFu);
}
static inline uint32_t make_gain_word(int ch, int tone, uint32_t g20) {
    return (0x2u << 28) | pack_sel(ch, tone) | (g20 & 0xFFFFFu);
}
static inline uint32_t make_index_commit_word(int ch, int tone, uint32_t idx20) {
    return (0x3u << 28) | pack_sel(ch, tone) | (idx20 & 0xFFFFFu);
}
static inline uint32_t make_gain_commit_word(int ch, int tone, uint32_t g20) {
    return (0x4u << 28) | pack_sel(ch, tone) | (g20 & 0xFFFFFu);
}

static void sleep_ns(long ns) {
    struct timespec ts;
    ts.tv_sec  = ns / 1000000000L;
    ts.tv_nsec = ns % 1000000000L;
    clock_nanosleep(CLOCK_MONOTONIC, 0, &ts, NULL);
}

int main(void) {
    if (awg_init() < 0) {
        fprintf(stderr, "Failed to init AWG core\n");
        return 1;
    }

    const int CH_A   = 0;
    const int TONE_0 = 0;
    const long GAP_NS = 200000;  // 0.2 ms, tune as needed

    printf("Loop: A.tone0 -> 1k (max) commit -> 20k (max) commit -> repeat\n");

    for (;;) {
        // --- Switch to 1 kHz (safe order: plain write, then *COMMIT* on last) ---
        {
            uint32_t w[2];
            w[0] = make_index_word(CH_A, TONE_0, IDX_1K);                // plain
            w[1] = make_gain_commit_word(CH_A, TONE_0, GAIN_Q1_17_MAX);  // commit here
            awg_send_words32(w, 2);
        }
        sleep_ns(GAP_NS);

        // --- Switch to 20 kHz ---
        {
            uint32_t w[2];
            w[0] = make_index_word(CH_A, TONE_0, IDX_20K);               // plain
            w[1] = make_gain_commit_word(CH_A, TONE_0, GAIN_Q1_17_MAX);  // commit here
            awg_send_words32(w, 2);
        }
        sleep_ns(GAP_NS);
    }

    // awg_close(); // not reached in this loop
    // return 0;
}